# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
employee_leave_manager: Employee leave management system with approval workflow
Generated by ADK Agent Generator
"""

from datetime import datetime
from google.adk.agents.llm_agent import LlmAgent
from google.adk.agents.loop_agent import LoopAgent
from google.adk.agents.parallel_agent import ParallelAgent
from google.adk.agents.sequential_agent import SequentialAgent
from google.adk.tools.function_tool import FunctionTool
from google.genai import types
from typing import Dict, Any
from typing import Dict, Any, List
from typing import List, Dict, Any
from typing import List, Dict, Any, Optional
import json


# Tool: Check if employee has sufficient leave balance
def validate_leave_balance(employee_id: str, leave_type: str, days_requested: int, tool_context: ToolContext) -> Dict[str, Any]:
    \"\"\"Validate if employee has sufficient leave balance.
    
    Args:
        employee_id: Employee ID
        leave_type: Type of leave (annual, sick, personal)
        days_requested: Number of days requested
        tool_context: Tool execution context
        
    Returns:
        Validation result with balance information
    \"\"\"
    # Mock leave balance data (in production, this would query a database)
    leave_balances = {
        'annual': 20,
        'sick': 10,
        'personal': 5
    }
    
    available = leave_balances.get(leave_type, 0)
    is_valid = days_requested <= available
    
    return {
        'employee_id': employee_id,
        'leave_type': leave_type,
        'days_requested': days_requested,
        'available_balance': available,
        'is_valid': is_valid,
        'remaining_balance': available - days_requested if is_valid else available,
        'message': f"Request valid. {available - days_requested} days remaining." if is_valid else f"Insufficient balance. Only {available} days available."
    }

# Tool: Check for date conflicts with existing leave requests
def check_date_conflicts(employee_id: str, start_date: str, end_date: str, tool_context: ToolContext) -> Dict[str, Any]:
    \"\"\"Check for conflicts with existing leave requests.
    
    Args:
        employee_id: Employee ID
        start_date: Leave start date (YYYY-MM-DD)
        end_date: Leave end date (YYYY-MM-DD)
        tool_context: Tool execution context
        
    Returns:
        Conflict check result
    \"\"\"
    # Mock conflict check (in production, query database)
    # For demo, assume no conflicts
    
    return {
        'employee_id': employee_id,
        'start_date': start_date,
        'end_date': end_date,
        'has_conflicts': False,
        'conflicts': [],
        'message': 'No date conflicts found. Request can proceed.'
    }

# Tool: Route leave request to appropriate approver
def route_to_approver(employee_id: str, days_requested: int, leave_type: str, tool_context: ToolContext) -> Dict[str, Any]:
    \"\"\"Route request to appropriate approvers based on policy.
    
    Args:
        employee_id: Employee ID
        days_requested: Number of days
        leave_type: Type of leave
        tool_context: Tool execution context
        
    Returns:
        Routing information
    \"\"\"
    approvers = []
    
    # Routing logic
    if days_requested <= 3:
        approvers = ['manager']
    else:
        approvers = ['manager', 'hr']
    
    if leave_type == 'emergency':
        approvers.append('director')
    
    return {
        'employee_id': employee_id,
        'approvers': approvers,
        'approval_sequence': approvers,
        'message': f"Request routed to: {', '.join(approvers)}"
    }

# Tool: Update the approval status of a leave request
def update_approval_status(request_id: str, approver: str, status: str, comments: str, tool_context: ToolContext) -> Dict[str, Any]:
    \"\"\"Update approval status.
    
    Args:
        request_id: Leave request ID
        approver: Approver name/ID
        status: approved/rejected/pending
        comments: Approval comments
        tool_context: Tool execution context
        
    Returns:
        Updated status information
    \"\"\"
    timestamp = datetime.now().isoformat()
    
    return {
        'request_id': request_id,
        'approver': approver,
        'status': status,
        'comments': comments,
        'timestamp': timestamp,
        'message': f"Status updated to '{status}' by {approver}"
    }

# Tool: Send email notification
def send_email(recipient: str, subject: str, body: str, tool_context: ToolContext) -> Dict[str, Any]:
    \"\"\"Send email notification.
    
    Args:
        recipient: Email recipient
        subject: Email subject
        body: Email body
        tool_context: Tool execution context
        
    Returns:
        Send status
    \"\"\"
    # Mock email sending (in production, use actual email service)
    
    return {
        'recipient': recipient,
        'subject': subject,
        'status': 'sent',
        'message': f"Email sent to {recipient}: {subject}"
    }

# Tool: Send Slack notification
def send_slack_message(channel: str, message: str, tool_context: ToolContext) -> Dict[str, Any]:
    \"\"\"Send Slack message.
    
    Args:
        channel: Slack channel
        message: Message content
        tool_context: Tool execution context
        
    Returns:
        Send status
    \"\"\"
    # Mock Slack sending (in production, use Slack API)
    
    return {
        'channel': channel,
        'message': message,
        'status': 'sent',
        'message_sent': f"Slack message sent to #{channel}"
    }


# Handles employee leave requests and validates them
leave_request_handler = LlmAgent(
    name="leave_request_handler",
    model="gemini-1.5-flash",
    description="""
    Handles employee leave requests and validates them
    """,
    instruction="""
    You are a leave request handler for an employee leave management system.

Your responsibilities:
1. Accept leave requests from employees
2. Validate leave request details (dates, type, reason)
3. Check leave balance and eligibility
4. Format requests for approval

When processing a request:
- Verify employee has sufficient leave balance
- Check for date conflicts
- Ensure all required information is provided
- Create a structured request for approval

Be professional and helpful in all interactions.
    """,
    tools=[FunctionTool(validate_leave_balance), FunctionTool(check_date_conflicts)],
    generate_content_config=types.GenerateContentConfig(temperature=0.2)
)

# Manages the approval workflow for leave requests
approval_manager = LlmAgent(
    name="approval_manager",
    model="gemini-1.5-flash",
    description="""
    Manages the approval workflow for leave requests
    """,
    instruction="""
    You are an approval manager for leave requests.

Your responsibilities:
1. Review leave requests from employees
2. Route to appropriate approvers based on company policy
3. Track approval status
4. Handle approval/rejection decisions

Approval Rules:
- Requests <= 3 days: Manager approval only
- Requests > 3 days: Manager + HR approval
- Emergency leave: Immediate notification to manager

Maintain professional communication and clear status updates.
    """,
    tools=[FunctionTool(route_to_approver), FunctionTool(update_approval_status)],
    generate_content_config=types.GenerateContentConfig(temperature=0.1)
)

# Sends notifications about leave request status
notification_sender = LlmAgent(
    name="notification_sender",
    model="gemini-1.5-flash",
    description="""
    Sends notifications about leave request status
    """,
    instruction="""
    You are a notification manager for the leave management system.

Your responsibilities:
1. Send notifications to employees about request status
2. Notify managers of pending approvals
3. Send reminders for pending actions
4. Provide status updates

Notification Types:
- Request submitted confirmation
- Approval/rejection notifications
- Pending approval reminders
- Leave balance updates

Keep notifications clear, concise, and professional.
    """,
    tools=[FunctionTool(send_email), FunctionTool(send_slack_message)],
    generate_content_config=types.GenerateContentConfig(temperature=0.3)
)

# Coordinates the leave request and approval process
leave_coordinator = SequentialAgent(
    name="leave_coordinator",
    description="""
    Coordinates the leave request and approval process
    """,
    sub_agents=[leave_request_handler, approval_manager, notification_sender]
)


# Main agent (entry point)
root_agent = leave_coordinator
